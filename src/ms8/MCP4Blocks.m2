(* Ulm's Modula-2 Compiler    Solaris 2.x/SPARCv8
   -- partially derived from ETH Zurichs Modula-2 Compiler for Lilith --
   Copyright (C) 1983-1996 Universitaet Ulm, SAI, 89069 Ulm, Germany
             (C) 1979-1981 Institut fuer Informatik, ETH Zuerich, Switzerland
   ----------------------------------------------------------------------------
   Modula-2 has been designed and developed by Niklaus Wirth
   at the Institut fuer Informatik, ETH Zuerich, Switzerland
   ----------------------------------------------------------------------------
   Ulm's Modula-2 Compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   Ulm's Modula-2 Compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   $Id: MCP4Blocks.m2,v 0.1 1997/02/21 18:40:29 borchert Exp $
   ----------------------------------------------------------------------------
   $Log: MCP4Blocks.m2,v $
   Revision 0.1  1997/02/21  18:40:29  borchert
   Initial revision

   ----------------------------------------------------------------------------
*)

IMPLEMENTATION MODULE MCP4Blocks;

   (* code generation for block entries & exits *)

   FROM MCBase IMPORT Ident, Idptr, mainmodp, globvarnext, Symbol,
      Label, Idset, LocalReg, Type, Structform, Stset,
      oneword, doubleword, Offset, Size, Kindvar, Varkind, Idclass,
      ismain, root, noprio, stringroot, Stringptr, rvalroot,
      RealValuePtr, bigsetroot, SetValuePtr, addrptr, Recpart;
   FROM MCMnemonics IMPORT Mnemonic;
   FROM MCP4Attributes IMPORT tmpreg, top, Simm13, ArithmeticType, Reg,
      GetLabel, base;
   FROM MCP4BasicOps IMPORT ConstMulReg, AlignReg, LowHigh, GenReturn,
      MoveVarBytes, MoveBytes, LoadPosParams, LoadConst;
   FROM MCP4CodeSys IMPORT InitEmitCode,
      EmitHeader, EmitFileName, EmitAlign4, EmitAlign8, SetSegment, Segment,
      StrEmit, StrEmit1, StrEmit2, StrEmit3,
      Emit, Emit1, Emit2, Emit3, Emit4, EmitLabel,
      EmitBeginBlock1, EmitBeginBlock2, EmitKey, EmitString;
   FROM MCP4Global IMPORT Assert, Error;
   FROM MCP4Public IMPORT Kflag, sourcefilename, profile;
   FROM MCP4Register IMPORT GetReg, FreeReg, BeginBlock, EndBlock,
      RegRequest, Reserve;
   FROM MCP4Scanner IMPORT GetSymbol, sy, nptr, line, pline;
   FROM MCP4Stack IMPORT StackOffset, StackUse;
   FROM MCP4Statements IMPORT StatSequ1;
   FROM MCP4Types IMPORT IsArrayType, ByteSize;

   VAR
      (* exported
      level: CARDINAL; (* current block nest level *)
      blockNptr: Ident; (* current block *)
      *)
      stackUseLabel: Label; checkStackUse: BOOLEAN;

   PROCEDURE GenBegin;
      (* generate the first lines of our assembly file *)
   BEGIN
      InitEmitCode;
      StrEmit("%* code generated by Ulm's Modula-2 Compiler");
      StrEmit("%* for the Solaris 2.x / SPARCv8 platform");
      EmitFileName(sourcefilename);
      SetSegment(text);
      EmitAlign4;
      EmitHeader(mainmodp);
      StrEmit3("%:b(%n%s,%c)", mainmodp, ".V", globvarnext);
      StrEmit1("%e%n.V", mainmodp);
      StrEmit3("%:b(%n%s,%c)", mainmodp, ".I", oneword); (* init flag *)
      StrEmit2("%:l%n%s", mainmodp, ".N");
      StrEmit1("%:s", mainmodp^.identifier);
   END GenBegin;

   PROCEDURE GenEnd;
      (* generate last lines of assembly file *)
   BEGIN
      SetSegment(text);
      GenStrings; GenRealConsts; GenBigSetConsts;
   END GenEnd;

   PROCEDURE CompilationUnit;
   BEGIN
      GetSymbol;
      Block(NIL);
   END CompilationUnit;

   PROCEDURE GenStrings;
      VAR
	 sptr: Stringptr;
   BEGIN
      sptr := stringroot;
      WHILE sptr # NIL DO
	 WITH sptr^ DO
	    IF label.ok THEN
	       EmitString(sptr);
	    END;
	 END;
	 sptr := sptr^.slink;
      END;
   END GenStrings;

   PROCEDURE GenRealConsts;
      TYPE
	 DoubleInt = ARRAY [0..1] OF INTEGER;
      VAR
	 rptr: RealValuePtr;
	 int2: DoubleInt;
   BEGIN
      IF rvalroot # NIL THEN
	 StrEmit("%* real constants");
	 EmitAlign8;
	 rptr := rvalroot;
	 WHILE rptr # NIL DO
	    WITH rptr^ DO
	       IF label.ok THEN
		  EmitLabel(label);
		  int2 := DoubleInt(rptr^.rvalue);
		  StrEmit1("%:L%i", int2[0]);
		  StrEmit1("%:L%i", int2[1]);
	       END;
	    END;
	    rptr := rptr^.rlink;
	 END;
      END;
   END GenRealConsts;

   PROCEDURE GenBigSetConsts;
      TYPE
	 SetPtr = POINTER TO INTEGER;
      VAR
	 sptr: SetValuePtr;
	 bptr: SetPtr;
	 word: CARDINAL;
   BEGIN
      IF bigsetroot # NIL THEN
	 StrEmit("%* big set constants");
	 EmitAlign4;
	 sptr := bigsetroot;
	 WHILE sptr # NIL DO
	    WITH sptr^ DO
	       IF label.ok THEN
		  EmitLabel(label);
		  FOR word := 0 TO size - 1 DO
		     bptr := SetPtr(valentry + word * oneword);
		     StrEmit1("%:L%i", bptr^);
		  END;
	       END;
	    END;
	    sptr := sptr^.slink;
	 END;
      END;
   END GenBigSetConsts;

   PROCEDURE Align(VAR offset: Offset; align: Offset);
      CONST
	 maxint = MAX(Offset);
	 minint = MIN(Offset);
   BEGIN
      IF ABS(offset) MOD align # 0 THEN
	 IF offset >= 0 THEN
	    IF offset > maxint-align THEN
	       Error(100);
	    ELSE
	       INC(offset, align - offset MOD align);
	    END;
	 ELSE
	    IF offset < minint+align THEN
	       Error(100);
	    ELSE
	       DEC(offset, align - ABS(offset) MOD align);
	    END;
	 END;
      END;
   END Align;

   PROCEDURE Alloc(VAR nextOffset, offset: Offset; type: Type);
      VAR
	 space: Size;

      PROCEDURE ContainsReals(sp: Type) : BOOLEAN;
	 VAR
	    field: Idptr;
      BEGIN
	 IF sp = NIL THEN RETURN FALSE END;
	 WITH sp^ DO
	    CASE form OF
	    | reals, longreals:
		  RETURN TRUE
	    | arrays:
		  RETURN ContainsReals(elp)
	    | records:
		  CASE rpart OF
		  | fixedpart:
			field := fieldp;
			WHILE field # NIL DO
			   IF ContainsReals(field^.idtyp) THEN
			      RETURN TRUE
			   END;
			   field := field^.link;
			END;
			RETURN ContainsReals(tagp)
                  | tagfield:
			RETURN ContainsReals(fstvarp) OR
			       ContainsReals(elsevarp)
                  | variantpart:
			RETURN ContainsReals(nxtvarp) OR
			       ContainsReals(subtagp)
		  END;
	    ELSE
	       RETURN FALSE
	    END;
	 END;
      END ContainsReals;

   BEGIN
      IF IsDyn(type) THEN
	 space := doubleword;
      ELSE
	 space := type^.size;
      END;
      IF ContainsReals(type) THEN
	 Align(nextOffset, doubleword);
      ELSIF space >= oneword THEN
	 Align(nextOffset, oneword);
      END;
      offset := nextOffset; INC(nextOffset, VAL(Offset, space));
   END Alloc;

   PROCEDURE ToBeMadeAddressable(varp: Ident) : BOOLEAN;
      (* return TRUE if the parameter must be copied from
	 the input register to stack to make it addressable
      *)
   BEGIN
      WITH varp^ DO
	 RETURN inReg &
		((vkind = valparam) & addressNeeded OR
		nestedAccess)
      END;
   END ToBeMadeAddressable;

   PROCEDURE AllocateLocalVars(procp: Ident);
      (* the allocation of the 2nd pass is preliminary only;
	 with the knowledge of the 3rd pass (flags addressNeeded,
	 readOnly & nestedAccess) we reallocate all local vars
	 and try to utilize the registers l0..l5 of the
	 register window
      *)
      VAR
	 varp: Ident;
	 nextReg: [0..MAX(LocalReg)+1]; (* number of used regs so far *)
	 nextOffset: Offset; (* next offset on stack *)
	 space: CARDINAL;
   BEGIN
      WITH procp^ DO
	 nextReg := 0; nextOffset := 0;
	 varp := locvarp;
	 WHILE varp # NIL DO
	    WITH varp^ DO
	       Assert(state = local);
	       IF (nextReg > MAX(LocalReg)) OR
	             addressNeeded OR nestedAccess OR
		     (idtyp^.size > oneword) OR
		     (idtyp^.form IN Stset{reals, longreals, arrays,
			records, bigsets}) THEN
		  (* allocation on stack *)
		  Alloc(nextOffset, voffset, idtyp);
	       ELSE
		  (* allocation in local register *)
		  vaddr := 0; voffset := 0;
		  inReg := TRUE; lreg := nextReg; INC(nextReg);
	       END;
	    END;
	    varp := varp^.vlink;
	 END;
	 Align(nextOffset, doubleword);
	 varlength := nextOffset;
	 (* compute relative offsets to base *)
	 varp := locvarp;
	 WHILE varp # NIL DO
	    WITH varp^ DO
	       IF ~inReg THEN
		  voffset := - nextOffset + voffset;
	       END;
	    END;
	    varp := varp^.vlink;
	 END;
      END;
   END AllocateLocalVars;

   PROCEDURE IsDyn(type: Type) : BOOLEAN;
   BEGIN
      WITH type^ DO
	 RETURN (form = arrays) & dyn
      END;
   END IsDyn;

   PROCEDURE InitParamOffsets(procp: Ident);
      VAR
	 varp: Ident;
   BEGIN
      varp := procp^.idtyp^.fstparam;
      WHILE varp # NIL DO
	 WITH varp^ DO
	    Assert(state = local);
	    IF inReg THEN
	       voffset := 0;
	    ELSE
	       voffset := vaddr;
	    END;
	 END;
	 varp := varp^.vlink;
      END;
   END InitParamOffsets;

   PROCEDURE AllocCopyParameters(procp: Ident);
      (* variable parameters are allocated too if they are accessed
	 from one of our local procedures
      *)
      VAR
	 varp: Ident;
	 nextOffset: Offset;
	 reg: Reg;
   BEGIN
      nextOffset := 0;
      varp := procp^.idtyp^.fstparam;
      WHILE varp # NIL DO
	 WITH varp^ DO
	    IF (vkind = copyparam) & ~IsDyn(idtyp) OR
		  ToBeMadeAddressable(varp) THEN
	       IF (vkind = varparam) & ~IsDyn(idtyp) THEN
		  Alloc(nextOffset, voffset, addrptr);
	       ELSE
		  Alloc(nextOffset, voffset, idtyp);
	       END;
	    END;
	 END;
	 varp := varp^.vlink;
      END;
      Align(nextOffset, doubleword);
      INC(procp^.varlength, nextOffset);
      varp := procp^.idtyp^.fstparam;
      WHILE varp # NIL DO
	 WITH varp^ DO
	    IF (vkind = copyparam) & ~IsDyn(idtyp) OR
		  ToBeMadeAddressable(varp) THEN
	       voffset := - VAL(Offset, procp^.varlength) + voffset;
	    END;
	 END;
	 varp := varp^.vlink;
      END;
   END AllocCopyParameters;

   PROCEDURE Block(fnptr: Idptr);
      VAR 
	 procnptr: Idptr;
   BEGIN 
      (* calculate base offset *)
      IF (fnptr # NIL) & (fnptr^.klass IN Idset{pures, funcs}) THEN
	 AllocateLocalVars(fnptr);
	 InitParamOffsets(fnptr);
	 AllocCopyParameters(fnptr);
      END;
      WHILE (sy = proceduresy) DO 
         procnptr := nptr;
         GetSymbol;
         INC(level);
         Block(procnptr);
         DEC(level);
      END;
      IF fnptr # NIL THEN
	 blockNptr := fnptr;
	 GenBlockEntry;
	 IF sy = beginsy THEN 
	    GetSymbol;
	    StatSequ1(endblock);
	 END;
	 TerminateBlock;
      END;
      Assert(sy = endblock);
      GetSymbol; (*endblock*)
   END Block;

   PROCEDURE ReserveRegs(procp: Ident);
      VAR
	 varp: Ident;
	 reg: Reg;
	 done: BOOLEAN;
   BEGIN
      WITH procp^ DO
	 varp := locvarp;
	 WHILE varp # NIL DO
	    WITH varp^ DO
	       IF inReg THEN
		  Assert(vkind = noparam);
		  reg := VAL(Reg, ORD(l0) + lreg); Reserve(reg);
	       END;
	    END;
	    varp := varp^.vlink;
	 END;
	 varp := idtyp^.fstparam;
	 WHILE varp # NIL DO
	    WITH varp^ DO
	       IF inReg THEN
		  Assert(vkind # noparam);
		  reg := VAL(Reg, ORD(i0) + preg);
		  IF IsDyn(idtyp) & ~ToBeMadeAddressable(varp) THEN
		     Reserve(reg);
		     reg := VAL(Reg, ORD(reg) + 1);
		     Reserve(reg);
		  ELSIF (vkind = copyparam) OR ToBeMadeAddressable(varp) THEN
		     RegRequest(reg, done); Assert(done);
		     IF IsDyn(idtyp) THEN
			reg := VAL(Reg, ORD(reg) + 1);
			RegRequest(reg, done); Assert(done);
		     END;
		  ELSE
		     Reserve(reg);
		  END;
	       END;
	    END;
	    varp := varp^.vlink;
	 END;
      END;
   END ReserveRegs;

   (* stack layout:

			+------------------+  +
			|         .        |  |
			|         .        |  |
			+------------------+  |
			|  1st parameter   |  | parlength
			+------------------+  |
			|   static link    |  |
			+------------------+  | +
			| reserverd for    |  | | procmarkspace
			| regwin overflows |  | |
            base -----> +------------------+  + +
	                |   local vars     |  | varlength
			|                  |  |
			+------------------+  +
			| statically       |  |
			| allocated via    |  | alloclength
			| MCP4Stack        |  |
			+------------------+  +
			| dynamic arrays   |
			|                  |
			+------------------+  +
			| parameters for   |  |
			| callee           |  | maxparlength
			+------------------+  |
			|   static link    |  |
			+------------------+  | +
			| reserverd for    |  | | procmarkspace
			| regwin overflows |  | |
             top -----> +------------------+  + +

      the stackuse label which is given as argument to SAVE
      and later emitted by TerminateBlock is the sum of
      varlength, alloclength and maxparlength;
      dynamic arrays are allocated by moving top accordingly;
      
      addressing:
	 incoming parameters, local variables and
	    static allocations:                       by base
	 dynamic arrays:                              by pointers
	 outgoing parameters:                         by top

      note that all areas are aligned on 8-byte boundaries
   *)

   PROCEDURE GenBlockEntry;
      CONST
	 mainLabel = "I.main";
      VAR 
	 beginLabel: Label;
	 lpp, lvp: Idptr;
	 srcReg, destReg, lenReg: Reg;
	 highReg, ptrReg: Reg;
	 low, high: Offset;
   BEGIN 
      Assert(blockNptr # NIL);
      WITH blockNptr^ DO
	 BeginBlock;
	 SetSegment(text);
	 StrEmit1("%:l%n", blockNptr);
	 StrEmit1("%g%n", blockNptr);
	 EmitBeginBlock1(blockNptr, line);
	 IF ismain AND (procnum = 0) THEN
	    StrEmit1("%:l%_%s", mainLabel);
	    StrEmit1("%g%_%s", mainLabel);
	 END;
	 IF idtyp # NIL THEN
	    StrEmit1("%* parlength     = %c", idtyp^.parlength);
	    StrEmit1("%* parregs       = %c", idtyp^.parregs);
	 END;

	 IF blockNptr = mainmodp THEN
	    (* check whether this module is already initialized *)
	    GetLabel(beginLabel);
	    Emit3(SETHI, "%H(%n%s),%r", mainmodp, ".I", tmpreg);
	    Emit4(LDSTUB, "%[r,%L(%n%s)],%r", tmpreg, mainmodp, ".I", tmpreg);
	    Emit3(SUBcc, "%r,%r,%r", tmpreg, g0, g0);
	    Emit1(BE, "%l", beginLabel); Emit(NOP, "");
	    Emit(RETL, ""); Emit(NOP, "");
	    EmitLabel(beginLabel);
	 END;

	 (* StackUse: symbol for allocated stack size in bytes *)
	 GetLabel(stackUseLabel);

	 (* set up activation record *)
	 IF Kflag OR (VAL(Offset, varlength) >= MAX(Simm13) DIV 2) THEN 
	    Emit3(SAVE, "%r,%L(%l),%r", top, stackUseLabel, top);
	    Emit2(SETHI, "%H(%l),%r", stackUseLabel, tmpreg);
	    Emit3(ADD, "%r,%r,%r", top, tmpreg, top);
	    checkStackUse := FALSE;
	 ELSE
	    Emit3(SAVE, "%r,%l,%r", top, stackUseLabel, top);
	    checkStackUse := TRUE;
	 END;

	 StackOffset(-VAL(Offset, varlength));
	 IF blockNptr = mainmodp THEN
	    lpp := root^.locp^.link;
	    lvp := NIL;

	    (* initialize imported modules *)
	    WHILE lpp # NIL DO
	       IF lpp # mainmodp THEN
		  EmitKey(lpp);
		  StrEmit1("%e%n", lpp);
		  Emit2(CALL, "%n,%c", lpp, 0); Emit(NOP, "");
	       END;
	       lpp := lpp^.link;
	    END;
	 ELSIF klass = mods THEN
	    lpp := NIL; lvp := NIL;
	 ELSE (* proc/func entry *)
	    ReserveRegs(blockNptr);

	    lvp := locvarp;
	    lpp := idtyp^.fstparam;

	    (* allocate space for copy parameters *)
	    WHILE lpp # NIL DO
	       WITH lpp^ DO
		  IF vkind = copyparam THEN
		     IF IsDyn(idtyp) THEN
			GetReg(lenReg);
			IF inReg THEN
			   ptrReg := VAL(Reg, ORD(i0) + preg);
			   highReg := VAL(Reg, ORD(i0) + preg + 1);
			   Emit3(ADD, "%r,%c,%r", highReg, 1, lenReg);
			   IF NOT ByteSize(idtyp^.elp) THEN
			      ConstMulReg(cardAT, lenReg, idtyp^.elp^.size);
			      IF idtyp^.elp^.size MOD doubleword # 0 THEN
				 AlignReg(lenReg, lenReg);
			      END;
			   ELSIF idtyp^.elp^.size MOD doubleword # 0 THEN
			      AlignReg(lenReg, lenReg);
			   END;
			ELSE
			   (* MCP4CallSys: vaddr(base) = copy address *)
			   (*      vaddr+oneword(base) = HIGH         *)
			   Emit3(LD, "%[r,d],%r", base, vaddr+oneword, lenReg);
			   Emit3(ADD, "%r,%c,%r", lenReg, 1, lenReg);
			   IF NOT ByteSize(idtyp^.elp) THEN
			      ConstMulReg(cardAT, lenReg, idtyp^.elp^.size);
			   END;
			   IF idtyp^.elp^.size MOD doubleword # 0 THEN
			      AlignReg(lenReg, lenReg);
			   END;
			END;
			Emit3(SUB, "%r,%r,%r", top, lenReg, top);
			GetReg(destReg);
			LowHigh(blockNptr^.maxparlength, low, high);
			IF high = 0 THEN
			   Emit3(ADD, "%r,%c,%r",
			      top, blockNptr^.maxparlength, destReg);
			ELSE
			   Emit2(SETHI, "%i,%r", high, tmpreg);
			   Emit3(ORop, "%r,%i,%r", tmpreg, low, destReg);
			   Emit3(ADD, "%r,%r,%r", top, destReg, destReg);
			END;
			GetReg(srcReg);
			IF inReg THEN
			   Emit3(ORop, "%r,%r,%r", ptrReg, g0, srcReg);
			   IF ToBeMadeAddressable(lpp) THEN
			      Emit3(ST, "%r,%[r,d]", destReg, base, voffset);
			      Emit3(ST, "%r,%[r,d]", highReg,
				 base, voffset + oneword);
			      FreeReg(ptrReg); FreeReg(highReg);
			   ELSE
			      Emit3(ORop, "%r,%r,%r", destReg, g0, ptrReg);
			   END;
			ELSE
			   Emit3(LD, "%[r,d],%r", base, vaddr, srcReg);
			   Emit3(ST, "%r,%[r,d]", destReg, base, vaddr);
			END;
			MoveVarBytes(srcReg, destReg, lenReg);
		     ELSE
			Assert(idtyp^.size MOD oneword = 0);
			IF inReg THEN
			   srcReg := VAL(Reg, ORD(i0) + preg);
			ELSE
			   GetReg(srcReg);
			   Emit3(LD, "%[r,d],%r", base, vaddr, srcReg);
			END;
			GetReg(destReg);
			LowHigh(voffset, low, high);
			IF high = 0 THEN
			   Emit3(ADD, "%r,%i,%r", base, voffset, destReg);
			ELSE
			   Emit2(SETHI, "%i,%r", high, tmpreg);
			   Emit3(ORop, "%r,%i,%r", tmpreg, low, tmpreg);
			   Emit3(ADD, "%r,%r,%r", base, tmpreg, destReg);
			END;
			MoveBytes(srcReg, destReg, idtyp^.size);
		     END;
		  ELSIF ToBeMadeAddressable(lpp) THEN
		     srcReg := VAL(Reg, ORD(i0) + preg);
		     LowHigh(voffset, low, high);
		     IF high = 0 THEN
			IF IsDyn(idtyp) THEN
			   Emit3(ST, "%r,%[r,d]", srcReg, base, voffset);
			   FreeReg(srcReg);
			   srcReg := VAL(Reg, ORD(srcReg) + 1);
			   Emit3(ST, "%r,%[r,d]", srcReg,
			      base, voffset + oneword);
			ELSIF vkind = varparam THEN
			   Emit3(ST, "%r,%[r,d]", srcReg, base, voffset);
			ELSE
			   Emit4(STORE, "%r,%[r,d]", idtyp,
			      srcReg, base, voffset);
			END;
		     ELSE
			LoadConst(tmpreg, voffset);
			IF IsDyn(idtyp) THEN
			   Emit3(ST, "%r,%[r,r]", srcReg, base, tmpreg);
			   FreeReg(srcReg);
			   srcReg := VAL(Reg, ORD(srcReg) + 1);
			   Emit3(ADD, "%r,%c,%r", tmpreg, oneword, tmpreg);
			   Emit3(ST, "%r,%[r,r]", srcReg, base, tmpreg);
			ELSIF vkind = varparam THEN
			   Emit3(ST, "%r,%[r,r]", srcReg, base, tmpreg);
			ELSE
			   Emit4(STORE, "%r,%[r,r]",
			      idtyp, srcReg, base, tmpreg);
			END;
		     END;
		     FreeReg(srcReg);
		  END;
	       END;
	       lpp := lpp^.vlink;
	    END;
	 END;

	 (* enter priority (if necessary) *)
	 IF (plev = 1) AND (priolev # noprio) THEN
	    StrEmit1("%* entering priority %c", priolev);
	 END;

	 (* count procedure calls if profile is on *)
	 IF profile THEN
	    StrEmit("%* counting procedure calls");
	 END;
	 (* generate special label for the debugger (for breakpoints) *)
	 EmitBeginBlock2(blockNptr, line);
	 pline := 1;
      END;
   END GenBlockEntry;

   PROCEDURE TerminateBlock;
      VAR
	 alloclength: Size;
	 stackuse: Offset;
   BEGIN
      Assert(blockNptr # NIL);
      WITH blockNptr^ DO
	 IF klass = funcs THEN
	    (* a function must return a value *)
	    StrEmit("%* function does not return any value?");
	    LoadPosParams;
	    Emit1(CALL, "%_%s", ".fret"); Emit(NOP, "");
	 ELSE
	    GenReturn;
	 END;
	 EndBlock; (* for register management *)
	 StackUse(alloclength);
	 stackuse := varlength + alloclength + maxparlength;
	 Assert(stackuse MOD doubleword = 0);
	 stackuse := - stackuse;
	 IF checkStackUse & (stackuse <= MIN(Simm13)) THEN
	    Error(400);
	 END;
	 StrEmit1("%* varlength     = %c", varlength);
	 StrEmit1("%* alloclength   = %c", alloclength);
	 StrEmit1("%* maxparlength  = %c", maxparlength);
	 StrEmit2("%:D%l%:=%i", stackUseLabel, stackuse);
      END;
   END TerminateBlock;

BEGIN
   level := 0;
END MCP4Blocks.
