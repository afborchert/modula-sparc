(* Ulm's Modula-2 Compiler    Solaris 2.x/SPARCv8
   -- partially derived from ETH Zurichs Modula-2 Compiler for Lilith --
   Copyright (C) 1983-1996 Universitaet Ulm, SAI, 89069 Ulm, Germany
             (C) 1979-1981 Institut fuer Informatik, ETH Zuerich, Switzerland
   ----------------------------------------------------------------------------
   Note that Modula-2 has been designed and developed by Niklaus Wirth
   at the Institut fuer Informatik, ETH Zuerich, Switzerland
   ----------------------------------------------------------------------------
   Ulm's Modula-2 Compiler is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2 of
   the License, or (at your option) any later version.

   Ulm's Modula-2 Compiler is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   $Id: MCP1Ident.m2,v 0.1 1997/02/21 18:40:24 borchert Exp $
   ----------------------------------------------------------------------------
   $Log: MCP1Ident.m2,v $
   Revision 0.1  1997/02/21  18:40:24  borchert
   Initial revision

   ----------------------------------------------------------------------------
*)

IMPLEMENTATION MODULE MCP1Ident;   (* LG *)
                                   (* REV AFB 1/84 *)
                                   (* REV AFB 5/84: see MCPass2.m2 *)

  FROM Memory IMPORT ALLOCATE, DEALLOCATE;
  FROM MCBase IMPORT noprio, Idptr, Stptr, Idclass, Structform, Varkind,
     Kindvar, Stpures, Stfuncs, Spellix, Symbol, root, boolptr, charptr,
     intptr, cardptr, realptr, wordptr, byteptr, bitsetptr, strptrs,
     substptr, addrptr, procptr, processptr, mainmodp, sysmodp, longcardptr,
     longintptr, longrealptr, modrev, maxcard, modrev2, nilvalue;
  FROM MCP1IO IMPORT HashIdent, EnterResWord, String14, spix;
  FROM MCBase IMPORT BitsPerWord, onebyte, oneword, realsize,
     procmarkspace, longword, longrealsize, doubleword;

  VAR curlistp : Idptr;

  PROCEDURE EnterName(VAR p: Idptr; VAR str: String14);
    (* initialisation and name entry *)
    VAR p1, p2: Idptr;
  BEGIN
    HashIdent(str);
    WITH p^ DO (* initialise *)
      name := spix; (* generated by HashIdent *)
      link := NIL;
      idtyp := NIL;
      globmodp := mainmodp;
    END;
    p1 := curlistp;
    WHILE (p1 <> NIL) AND (spix > p1^.name) DO
      p2 := p1;
      p1 := p1^.link;
    END;
    p^.link := p1;
    IF p1=curlistp THEN curlistp := p ELSE p2^.link := p END
  END EnterName;

  PROCEDURE EnterMod(sysmod: BOOLEAN);
    VAR p : Idptr;
        str : String14;
  BEGIN 
    NEW(p,mods,FALSE,mods,FALSE); 
    mainmodp := p;
    IF sysmod THEN
      str := "SYSTEM";
      HashIdent(str)
    ELSE
      root := p;
      str := "S.M."; (* standard module *)
      HashIdent(str);
    END;
    WITH p^ DO
      name := spix; klass := mods;
      globmodp := mainmodp;
      link := NIL; idtyp := NIL;
      expp := NIL; impp := NIL; locp := NIL;
      msp := NIL; isstandard := FALSE;
      priolev := noprio;
      externalaccess := FALSE;
      qualexp := sysmod; (* if TRUE then module SYSTEM *) 
      globalmodule := FALSE;
    END;
    curlistp := NIL;
  END EnterMod;

  PROCEDURE EnterProc(str: String14; pn: Stpures; tp: Stptr);
    VAR p: Idptr; 
  BEGIN
    NEW(p, pures, TRUE);
    EnterName(p,str);
    WITH p^ DO
      klass := pures;
      idtyp := tp; (* must be <> NIL for substituted procedures *)
      isstandard := TRUE;
      pname := pn;
    END;
  END EnterProc;

  PROCEDURE EnterFunc(str: String14; fn: Stfuncs);
    VAR p: Idptr; 
  BEGIN
    NEW(p, funcs, TRUE);
    EnterName(p,str);
    WITH p^ DO
      klass := funcs;
      isstandard := TRUE;
      fname := fn;
    END;
  END EnterFunc;

  PROCEDURE BaseType(sf: Structform): Stptr;
    VAR sp : Stptr;
  BEGIN 
    NEW(sp,bools);
    WITH sp^ DO 
      CASE sf OF
      | bytes, chars, bools: size := onebyte;
      | ints, cards, words: size := oneword;
      | longints, longcards: size := longword;
      | reals: size := realsize;
      | longreals: size := longrealsize;
      END;
      stidp := NIL; inlist := TRUE;
      form := sf; 
    END;
    RETURN sp
  END BaseType; 

  (* subrange of type CARDINAL *)

  PROCEDURE SubrStruct(mi,ma: CARDINAL): Stptr;
    VAR sp : Stptr;
  BEGIN 
    NEW(sp,subranges);
    WITH sp^ DO
      size := oneword; form := subranges;
      stidp := NIL; inlist := TRUE;
      scalp := cardptr;
      min := mi; max := ma; 
    END;
    RETURN sp
  END SubrStruct; 

  PROCEDURE PointerStruct(tp : Stptr): Stptr;
    VAR sp : Stptr;
  BEGIN 
    NEW(sp,pointers);
    WITH sp^ DO
      size := oneword; form := pointers;
      stidp := NIL; inlist := TRUE;
      elemp := tp;
    END;
    RETURN sp
  END PointerStruct;

  PROCEDURE SetStruct(): Stptr;
    VAR sp : Stptr;
  BEGIN 
    NEW(sp, sets, sets); 
    WITH sp^ DO
      size := oneword; form := sets;
      stidp := NIL; inlist := TRUE;
      basep := SubrStruct(0, BitsPerWord-1);
    END;
    RETURN sp
  END SetStruct;

  PROCEDURE ProcedureStruct(fp: Idptr): Stptr;
    VAR sp: Stptr;
        parp: Idptr;
  BEGIN 
    NEW(sp, proctypes, pures);
    WITH sp^ DO
      size := oneword; form := proctypes; rkind := pures;
      stidp := NIL; inlist := TRUE;
      fstparam := fp;
      parlength := procmarkspace;
      parp := fp;
      (* calculate parlength *)
      WHILE parp <> NIL DO
         WITH parp^ DO
	    IF ((vkind = copyparam) OR (vkind = varparam)) AND
	       (idtyp^.form = arrays) AND idtyp^.dyn OR
	       (idtyp = realptr) THEN
	       IF vaddr+doubleword > parlength THEN 
		  parlength := vaddr+doubleword;
	       END;
	    ELSIF vaddr+oneword > parlength THEN
	       parlength := vaddr+oneword;
	    END;
            parp := vlink;
         END;
      END;
    END;
    RETURN sp;
  END ProcedureStruct; 

  PROCEDURE EnterVar(str: String14; tp: Stptr; ad: CARDINAL);
    VAR p : Idptr;
  BEGIN
    NEW(p,vars);
    EnterName(p,str);
    WITH p^ DO
      idtyp := tp;
      klass := vars;
      indaccess := FALSE;
      vlevel := 0;
      vaddr := ad;
      state := absolute;
      vkind := noparam;
      vlink := NIL;
    END; 
  END EnterVar;
    
  PROCEDURE EnterParam(tp: Stptr; ad: CARDINAL; vk: Varkind; VAR np: Idptr); 
    VAR p : Idptr;
  BEGIN
    NEW(p,vars);
    WITH p^ DO
      name := 0; idtyp := tp;
      globmodp := mainmodp;
      klass := vars;
      indaccess := vk = varparam;
      vlevel := 1;
      vaddr := ad;
      state := local;
      vkind := vk;
      vlink := np 
    END; 
    np := p
  END EnterParam;    

  PROCEDURE EnterType(str: String14; tp: Stptr);
    VAR p : Idptr;
  BEGIN 
    NEW(p,types); 
    EnterName(p,str);
    WITH p^ DO
      klass := types;
      idtyp := tp;
    END;
    tp^.stidp := p; (* link structure with name *)
  END EnterType;

  PROCEDURE EnterConst(str: String14; tp: Stptr; valu: CARDINAL);
    VAR p : Idptr;
  BEGIN 
    NEW(p,consts);
    EnterName(p,str);
    WITH p^ DO
      idtyp := tp;
      klass := consts;
      cvalue.value := valu;
    END;
  END EnterConst; 

  PROCEDURE InitResWords;
  BEGIN
    EnterResWord('AND',andsy);            (* reserved words *)
    EnterResWord('DIV',divsy);
    EnterResWord('MOD',modsy);
    EnterResWord('NOT',notsy);
    EnterResWord('OR',orsy);
    EnterResWord('IN',insy);
    EnterResWord('CONST',constsy);
    EnterResWord('TYPE',typesy);
    EnterResWord('VAR',varsy);
    EnterResWord('ARRAY',arraysy);
    EnterResWord('RECORD',recordsy); 
    EnterResWord('SET',setsy);
    EnterResWord('POINTER',pointersy); 
    EnterResWord('TO',tosy);
    EnterResWord('IMPORT',importsy); 
    EnterResWord('EXPORT',exportsy); 
    EnterResWord('FROM',fromsy);
    EnterResWord('QUALIFIED',qualifiedsy);
    EnterResWord('DEFINITION',definitionsy);
    EnterResWord('IMPLEMENTATION',implementationsy);
    EnterResWord('PROCEDURE',proceduresy);
    EnterResWord('MODULE',modulesy); 
    EnterResWord('BEGIN',beginsy);
    EnterResWord('CASE',casesy);
    EnterResWord('OF',ofsy);
    EnterResWord('IF',ifsy);
    EnterResWord('THEN',thensy);
    EnterResWord('ELSIF',elsifsy);
    EnterResWord('ELSE',elsesy);
    EnterResWord('LOOP',loopsy);
    EnterResWord('EXIT',exitsy);
    EnterResWord('REPEAT',repeatsy); 
    EnterResWord('UNTIL',untilsy);
    EnterResWord('WHILE',whilesy);
    EnterResWord('WITH',withsy);
    EnterResWord('DO',dosy);
    EnterResWord('FOR',forsy);
    EnterResWord('BY',bysy);
    EnterResWord('RETURN',returnsy); 
    EnterResWord('END',endsy);
  END InitResWords;

  PROCEDURE InitStandards;
    VAR niltypeptr : Stptr;
        parp : Idptr;
        prp : Stptr;
        ix : CARDINAL;
  BEGIN
    (* standard module *)
    EnterMod(FALSE);
    boolptr := BaseType(bools);
    charptr := BaseType(chars);
    intptr := BaseType(ints);
    cardptr := BaseType(cards);
    realptr := BaseType(reals);
    bitsetptr := SetStruct();
    niltypeptr := PointerStruct(NIL);
    procptr := ProcedureStruct(NIL); (* PROCEDURE *)
    (* (* must be done always; for compatibility to symbol files *)
    IF modrev THEN
    *)
      longcardptr := BaseType(longcards);
      longintptr := BaseType(longints);
      longrealptr := BaseType(longreals);
    (*
    END;
    *)
    EnterType('BOOLEAN',boolptr);
    EnterType('CHAR',charptr);
    EnterType('INTEGER',intptr);
    EnterType('CARDINAL',cardptr);
    EnterType('REAL',realptr);
    EnterType('BITSET',bitsetptr);
    EnterType('NIL-TYPE',niltypeptr);
    EnterType('PROC',procptr);
    (* (* see above *)
    IF modrev THEN
    *)
      EnterType('LONGCARD', longcardptr);
      EnterType('LONGINT', longintptr);
      EnterType('LONGREAL', longrealptr);
    (*
    END;
    *)
    EnterConst('FALSE',boolptr,0);
    EnterConst('TRUE',boolptr,1); 
    EnterConst('NIL', niltypeptr, nilvalue);
    EnterProc('ARGV', argvp, NIL);   (* standard procedures *)
    EnterProc('DEC', decp,NIL);
    EnterProc('EXCL', exlp,NIL);
    EnterProc('HALT', halp,NIL);
    EnterProc('INC', incp,NIL);
    EnterProc('INCL', inlp,NIL);
    EnterProc('NEW', newp,NIL);
    EnterProc('DISPOSE', disp,NIL);
    EnterFunc('ABS', absf);           (* standard functions *)
    EnterFunc('ARGC', argcf);
    EnterFunc('CAP', capf);
    EnterFunc('CHR', chrf);
    EnterFunc('FLOAT', fltf);
    EnterFunc('HIGH', higf);
    IF modrev THEN
      EnterFunc('MAX', maxf);
      EnterFunc('MIN', minf);
    END;
    EnterFunc('ODD', oddf);
    EnterFunc('ORD', ordf);
    IF modrev2 THEN
       EnterFunc('SIZE', sizf);
    END;
    EnterFunc('TRUNC', trcf);
    EnterFunc('VAL', valf);
    mainmodp^.expp := curlistp;
    (* initialisation of string structure table *)
    FOR ix := 0 TO 20 DO strptrs[ix] := NIL END;
    (* module SYSTEM *)
    EnterMod(TRUE);
    wordptr := BaseType(words);
    byteptr := BaseType(bytes);
    processptr := PointerStruct(wordptr); 
    addrptr := SubrStruct(0B, maxcard);
    EnterType('WORD',wordptr);
    EnterType('BYTE',byteptr);
    IF NOT modrev2 THEN
       EnterType('PROCESS',processptr);
    END;
    EnterType('ADDRESS',addrptr);
    EnterProc('NEWPROCESS',nprp,NIL);    (* SYSTEM procedures *)
    EnterProc('TRANSFER',trsp,NIL);
    EnterFunc('ADR', adrf);              (* SYSTEM functions *)
    EnterFunc('SQRT', sqrf);
    IF NOT modrev2 THEN
       EnterFunc('SIZE', sizf);
    END;
    EnterFunc('TSIZE', tszf);
    EnterFunc('UNIXCALL', uxf);
    EnterFunc('UNIXFORK', uxff);
    EnterFunc('UNIXSIGNAL', uxsf);
    mainmodp^.expp := curlistp;
    sysmodp := mainmodp;
    (* initialisation of substitution procedures *)
    curlistp := NIL;
    parp := NIL;
    EnterParam(cardptr,procmarkspace + oneword,valparam,parp);
    EnterParam(addrptr,procmarkspace,varparam,parp);
    prp := ProcedureStruct(parp); (* PROCEDURE(VAR ADDRESS,CARDINAL) *)
    EnterProc("ALLOCATE",newp,prp); (* substitution for NEW *)
    EnterProc("DEALLOCATE",disp,prp); (* substitution for DISPOSE *)
    substptr := curlistp;
  END InitStandards;

  PROCEDURE InitIdTables;
  BEGIN
    InitResWords;
    InitStandards;
  END InitIdTables;

END MCP1Ident.
